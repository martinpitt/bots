name: issue-scan

on:
  issues:
    types: [opened, edited, reopened, labeled]
  pull_request:
    types: [opened, edited, synchronize, reopened, labeled]


jobs:
  scan:
    # Only run for issues/PRs with 'bot' label
    if: contains(github.event.*.labels.*.name, 'bot')
    runs-on: ubuntu-latest
    environment: image-build
    permissions:
      # create new branches
      contents: write
      # post statuses/comments
      issues: write
      pull-requests: write
      statuses: write
    # XXX: for testing on my fork only, don't land this
    env:
      COCKPIT_TESTMAP_INJECT: main/none
    steps:
      - name: Clone repository
        uses: actions/checkout@v5

      - name: Set up GitHub token
        run: |
          mkdir -p ~/.config/cockpit-dev
          echo '${{ secrets.GITHUB_TOKEN }}' > ~/.config/cockpit-dev/github-token

      - name: Scan issue/PR for tasks
        id: scan
        run: |
          # Scan the issue/PR for bot tasks
          GITHUB_BASE=${{ github.repository }} \
          ./issue-scan --issues-data '${{ toJSON(github.event) }}' > scan-output.json

          # for debugging
          cat scan-output.json

          # Check if we got any tasks
          if [ ! -s scan-output.json ]; then
            echo "No bot tasks found"
            exit 0
          fi

          # Extract just the sha (for commit_sha) and pass the whole job JSON (base64 encoded)
          SHA=$(jq -r '.job.sha' scan-output.json)
          JOB_JSON=$(jq -c '.job' scan-output.json)
          JOB_JSON_B64=$(echo "$JOB_JSON" | base64 -w0)

          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "job_json_b64=$JOB_JSON_B64" >> $GITHUB_OUTPUT

      - name: Determine git ref
        id: gitref
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "git_url=${{ github.event.pull_request.head.repo.clone_url }}" >> $GITHUB_OUTPUT
            echo "git_ref=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
          else
            echo "git_url=${{ github.event.repository.clone_url }}" >> $GITHUB_OUTPUT
            echo "git_ref=${{ github.event.repository.default_branch }}" >> $GITHUB_OUTPUT
          fi

      # https://api.dev.testing-farm.io/docs ; don't use sclorg/testing-farm-as-github-action4
      # as we don't want to poll (that's just a waste of GH action runner time)
      - name: Schedule on Testing Farm
        id: testing_farm
        if: steps.scan.outputs.job_json_b64 != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |

          # Build Testing Farm API request
          # compose does not matter much, we just need python-aiohttp and podman to for job-runner and the tasks container
          cat > tf-request.json << 'EOF'
          {
            "api_key": "${{ secrets.TESTING_FARM_RH_TOKEN }}",
            "test": {
              "fmf": {
                "url": "${{ steps.gitref.outputs.git_url }}",
                "ref": "${{ steps.gitref.outputs.git_ref }}",
                "name": "issue-scan"
              }
            },
            "environments": [{
              "arch": "x86_64",
              "os": {"compose": "Fedora-43-Updated"},
              "variables": {
                "JOB_JSON_B64": "${{ steps.scan.outputs.job_json_b64 }}"
              },
              "secrets": {
                "GITHUB_TOKEN": "${{ secrets.GITHUB_TOKEN }}",
                "S3_KEY_EU": "${{ secrets.S3_KEY_EU }}",
                "S3_KEY_US": "${{ secrets.S3_KEY_US }}",
                "S3_KEY_LOGS": "${{ secrets.S3_KEY_LOGS }}"
              },
              "hardware": {"virtualization": {"is-virtualized": true, "is-supported": true}}
            }],
            "settings": {
              "pipeline": {"timeout": 60}
            }
          }
          EOF

          # Submit to Testing Farm
          TF_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d @tf-request.json \
            https://api.dev.testing-farm.io/v0.1/requests)

          # Debug: show the whole response
          echo "Testing Farm response:"
          echo "$TF_RESPONSE" | jq .

          # Parse response
          TF_ID=$(echo "$TF_RESPONSE" | jq -r '.id')
          # TODO: don't hardcode this, extract from response
          TF_ARTIFACTS_URL="https://artifacts.osci.redhat.com/testing-farm/$TF_ID"

          echo "test_log_url=$TF_ARTIFACTS_URL" >> $GITHUB_OUTPUT

      - name: Post comment with Testing Farm link
        if: steps.scan.outputs.job_json_b64 != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine issue/PR number
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            ISSUE_NUMBER="${{ github.event.pull_request.number }}"
          else
            ISSUE_NUMBER="${{ github.event.issue.number }}"
          fi

          cat << COMMENT_EOF | gh issue comment "$ISSUE_NUMBER" --body-file -
          **Bot task scheduled on Testing Farm**

          \`\`\`json
          $(echo '${{ steps.scan.outputs.job_json_b64 }}' | base64 -d | jq .)
          \`\`\`

          Testing Farm logs: ${{ steps.testing_farm.outputs.test_log_url }}
          COMMENT_EOF
